<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Optimizing APIs for (web) apps: Backend for Frontend and other ideas - Updates on my GSoC project - Cristian Baldi</title><meta name="gridsome:hash" content="7c60a2f2409f77fa0735e48bcfea6819c253ebd9"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" name="description" content="Discover some patterns and ideas for optimizing APIs when developing web and mobile applications"><link data-vue-tag="ssr" href="https://cdn.materialdesignicons.com/5.3.45/css/materialdesignicons.min.css" rel="stylesheet"><link data-vue-tag="ssr" href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&amp;display=swap" rel="stylesheet"><link rel="preload" href="/assets/css/0.styles.93176963.css" as="style"><link rel="preload" href="/assets/js/app.29a151e2.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--post-vue.1dff21f4.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.c4b1ff07.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.64f03a1a.js"><link rel="prefetch" href="/assets/js/page--src--pages--photos-vue.b562ca5f.js"><link rel="prefetch" href="/assets/js/page--src--pages--posts-vue.b510fe74.js"><link rel="prefetch" href="/assets/js/page--src--pages--resume-vue.3841ce82.js"><link rel="stylesheet" href="/assets/css/0.styles.93176963.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div data-server-rendered="true" id="app" class="View View--Post" data-v-9281d02e><header class="Header View__heaader"><div class="Header__content"><a href="/" class="Header__title active">Cristian Baldi</a><div class="spacer"></div><nav class="Header__nav"><a href="https://github.com/crisbal" target="_blank" class="Header__link">Projects</a><a href="/photos" class="Header__link">Photos</a><a href="/posts" class="Header__link active">Posts</a></nav></div></header><main class="View__main"><article class="Post" data-v-9281d02e><header data-v-9281d02e><div class="Post__date" data-v-9281d02e>OnÂ <time datetime="2017-08-19" pubdate="pubdate" data-v-9281d02e>19 August 2017</time></div><h2 class="Post__title" data-v-9281d02e><a href="/posts/2017/08/19/optimizing-ap-is-for-web-apps-backend-for-frontend-and-other-ideas-updates-on-my-g-so-c-project/" aria-current="page" class="active--exact active" data-v-9281d02e>Optimizing APIs for (web) apps: Backend for Frontend and other ideas - Updates on my GSoC project</a></h2></header><div class="Post__content" data-v-9281d02e><blockquote>
<p>This is the fourth post in my GSoC series. You can read the third one [here]({{ site.url }}/blog/gsoc-updates-1).</p>
</blockquote>
<h2 id="an-introductory-example"><a href="#an-introductory-example" aria-hidden="true"><span class="icon icon-link"></span></a>An introductory example</h2>
<p>When building web apps (or internet-dependent apps in general), like I am doing for my [Google Summer of Code project]({{ site.url }}/blog/gsoc-at-ke), you are most likely fetching data from one or more external APIs (APIs that either you, your team or an external service developed).</p>
<p>Suppose you are building a web app for a wiki-like website (like I am doing), suppose again you are developing the home view for your web app. To render the home page you need to fetch some data, let's say recent edits, new users, the main categories your website is divided in, the "page of the day" and many other informations.</p>
<p>This means you would have to make many different calls to many different API endpoints before your page is fully rendered. It works but it is not ideal, especially if your user is, for example, on a mobile device with a mobile connection. Latency is high (and painful for the user) and before the page is rendered, even if the requests were performed in parallel, many seconds would pass.</p>
<p>Sometimes you can't even make these requests in parallel, a request might depend on the result of another request, again resulting in longer loading times.</p>
<h2 id="merging-the-requests-server-side"><a href="#merging-the-requests-server-side" aria-hidden="true"><span class="icon icon-link"></span></a>Merging the requests server-side</h2>
<p>One possible solution to the potential slowdown would be to create an addittional API service, developed and mainteined by you (or by the team developing the app) that externally exposes "complex"/elaborate endpoints.</p>
<p>Think for example of an <code>/api/homepage</code> endpoint. When you request this endpoint your service would request all the dependencies for the homepage (<code>/api/users</code>, <code>/api/page-of-the-day</code>, <code>/api/tags</code>, ...), add them to the same response object and send them back to you.</p>
<p>The first advantange we can see with this solution is that <strong>the number of requests is drastically reduced</strong>. Many requests gets "compressed" into one. Of course the response would be bigger but this would cut some time in term of latency.</p>
<p>Another advantage we can easily observe is that since our additional service is taking care of all the requests composing the complex request (let's call them sub-requests), these <strong>sub-requests are performed faster and in a more reliable way</strong> (the service has access to a more decent connection than your mobile phone).</p>
<p>Your service would also be able to provide additional logic that maybe the other API endpoints you are depending on are not providing. For example you could define caching rules so that sub-requests are performed every once in a while insted of at every request, returning cached results whenever you feel like it is the best to do so. Again this will result in faster requests from your app.</p>
<p>There are some (practical and not) disvantages to this proposed solution.</p>
<p>First of all it is a bit against RESTful ideals, instead of single, self contained resources (<code>/api/users</code>, <code>/api/page-of-the-day</code>, <code>/api/tags</code>) you have a whole object (<code>/api/homepage</code>).</p>
<p>Secondly this add an additional layer of complexity. You would need to develop an additional server that performs the sub-requests, not ideal if you are developing a project by yourself, but it might be worth for a performance increase.</p>
<h2 id="the-backend-for-frontend-pattern"><a href="#the-backend-for-frontend-pattern" aria-hidden="true"><span class="icon icon-link"></span></a>The Backend for Frontend pattern</h2>
<p>Another possibility would be to implement the <a href="http://samnewman.io/patterns/architectural/bff/" target="_blank" rel="nofollow noopener noreferrer">Backend for Frontend pattern</a>. The article gives a nice overview on the pattern but I will also try to give some insights on it.</p>
<p>This pattern is especially useful when you are building mobile applications together with web applications, both <strong>sharing a common API</strong>.</p>
<p>Usually, on the mobile application, you might want to show the same elements you show on the website, but with less detail, because <strong>it might be impossible to show on small screens all the available informations the full API provides</strong>. For example if we are displaying the recent users on a website we might want to show all the possibile details but on a mobile app we would hide for example their registration time, or their full name.</p>
<p>You could of course keep using the same API you use for the web, but this is not ideal because it means that <strong>you are downloading data that is partially not being used by your client</strong>.</p>
<p>The Backend for Frontend pattern tries to solve this issue. Instead of having only one API endpoint for all your devices, you would implement two (or more) API endpoints, each dealing with a different kind of device and application and each <strong>providing only the needed information</strong> (nothing more and nothing less).</p>
<p>For example instead of <code>/api/pages</code> you would have <code>/api/desktop/pages</code> and <code>/api/mobile/pages</code>.</p>
<p>Again you would need to develop an additional service, but this way you might save some precious time (and data) for your API clients.</p>
<p>You could combine this pattern with the previous one I presented to get best of both worlds: save data and save requests.</p>
<h2 id="summing-up"><a href="#summing-up" aria-hidden="true"><span class="icon icon-link"></span></a>Summing up</h2>
<p>If you are building a small and personal project you don't have to matter with the issues and solutions presented here. These ideas are important when you are building APIs and software for hundred of thousands of users, but I decided to investigate them for learning purposes. Let me know what you think in the comments.</p>
<hr>
<h3 id="gsoc-updates"><a href="#gsoc-updates" aria-hidden="true"><span class="icon icon-link"></span></a>GSoC updates</h3>
<p>In this last month of GSoC I was busy researching and testing various libraries to manage user authentication (think of login, logout and registering functionalities) that worked well with Vue.js. In the end, since we are going to use Keycloak for authenticating user in the WikiToLearn backend, I had to choose a library to integrate with Keycloak and, since there were none to integrate with Vue.js, I had to <a href="https://github.com/crisbal/vue-keycloak" target="_blank" rel="nofollow noopener noreferrer">create one kinda from scratch</a>. The last few days of GSoC will be spent completing and polishing this library which I plan to work on ever after GSoC. It is an "external" project but it is very related to [the project I am developing]({{ site.url }}/blog/gsoc-at-ke).</p>
</div></article></main><footer class="Footer View__footer"><a href="mailto:cristian@baldi.me" class="Footer__link">cristian@baldi.me</a></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"id":"d635642e452c2d4298656122af8ba252","title":"Optimizing APIs for (web) apps: Backend for Frontend and other ideas - Updates on my GSoC project","prettyDate":"19 August 2017","date":"2017-08-19","path":"\u002Fposts\u002F2017\u002F08\u002F19\u002Foptimizing-ap-is-for-web-apps-backend-for-frontend-and-other-ideas-updates-on-my-g-so-c-project\u002F","content":"\u003Cblockquote\u003E\n\u003Cp\u003EThis is the fourth post in my GSoC series. You can read the third one [here]({{ site.url }}\u002Fblog\u002Fgsoc-updates-1).\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"an-introductory-example\"\u003E\u003Ca href=\"#an-introductory-example\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EAn introductory example\u003C\u002Fh2\u003E\n\u003Cp\u003EWhen building web apps (or internet-dependent apps in general), like I am doing for my [Google Summer of Code project]({{ site.url }}\u002Fblog\u002Fgsoc-at-ke), you are most likely fetching data from one or more external APIs (APIs that either you, your team or an external service developed).\u003C\u002Fp\u003E\n\u003Cp\u003ESuppose you are building a web app for a wiki-like website (like I am doing), suppose again you are developing the home view for your web app. To render the home page you need to fetch some data, let's say recent edits, new users, the main categories your website is divided in, the \"page of the day\" and many other informations.\u003C\u002Fp\u003E\n\u003Cp\u003EThis means you would have to make many different calls to many different API endpoints before your page is fully rendered. It works but it is not ideal, especially if your user is, for example, on a mobile device with a mobile connection. Latency is high (and painful for the user) and before the page is rendered, even if the requests were performed in parallel, many seconds would pass.\u003C\u002Fp\u003E\n\u003Cp\u003ESometimes you can't even make these requests in parallel, a request might depend on the result of another request, again resulting in longer loading times.\u003C\u002Fp\u003E\n\u003Ch2 id=\"merging-the-requests-server-side\"\u003E\u003Ca href=\"#merging-the-requests-server-side\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMerging the requests server-side\u003C\u002Fh2\u003E\n\u003Cp\u003EOne possible solution to the potential slowdown would be to create an addittional API service, developed and mainteined by you (or by the team developing the app) that externally exposes \"complex\"\u002Felaborate endpoints.\u003C\u002Fp\u003E\n\u003Cp\u003EThink for example of an \u003Ccode\u003E\u002Fapi\u002Fhomepage\u003C\u002Fcode\u003E endpoint. When you request this endpoint your service would request all the dependencies for the homepage (\u003Ccode\u003E\u002Fapi\u002Fusers\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002Fapi\u002Fpage-of-the-day\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002Fapi\u002Ftags\u003C\u002Fcode\u003E, ...), add them to the same response object and send them back to you.\u003C\u002Fp\u003E\n\u003Cp\u003EThe first advantange we can see with this solution is that \u003Cstrong\u003Ethe number of requests is drastically reduced\u003C\u002Fstrong\u003E. Many requests gets \"compressed\" into one. Of course the response would be bigger but this would cut some time in term of latency.\u003C\u002Fp\u003E\n\u003Cp\u003EAnother advantage we can easily observe is that since our additional service is taking care of all the requests composing the complex request (let's call them sub-requests), these \u003Cstrong\u003Esub-requests are performed faster and in a more reliable way\u003C\u002Fstrong\u003E (the service has access to a more decent connection than your mobile phone).\u003C\u002Fp\u003E\n\u003Cp\u003EYour service would also be able to provide additional logic that maybe the other API endpoints you are depending on are not providing. For example you could define caching rules so that sub-requests are performed every once in a while insted of at every request, returning cached results whenever you feel like it is the best to do so. Again this will result in faster requests from your app.\u003C\u002Fp\u003E\n\u003Cp\u003EThere are some (practical and not) disvantages to this proposed solution.\u003C\u002Fp\u003E\n\u003Cp\u003EFirst of all it is a bit against RESTful ideals, instead of single, self contained resources (\u003Ccode\u003E\u002Fapi\u002Fusers\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002Fapi\u002Fpage-of-the-day\u003C\u002Fcode\u003E, \u003Ccode\u003E\u002Fapi\u002Ftags\u003C\u002Fcode\u003E) you have a whole object (\u003Ccode\u003E\u002Fapi\u002Fhomepage\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\n\u003Cp\u003ESecondly this add an additional layer of complexity. You would need to develop an additional server that performs the sub-requests, not ideal if you are developing a project by yourself, but it might be worth for a performance increase.\u003C\u002Fp\u003E\n\u003Ch2 id=\"the-backend-for-frontend-pattern\"\u003E\u003Ca href=\"#the-backend-for-frontend-pattern\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EThe Backend for Frontend pattern\u003C\u002Fh2\u003E\n\u003Cp\u003EAnother possibility would be to implement the \u003Ca href=\"http:\u002F\u002Fsamnewman.io\u002Fpatterns\u002Farchitectural\u002Fbff\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EBackend for Frontend pattern\u003C\u002Fa\u003E. The article gives a nice overview on the pattern but I will also try to give some insights on it.\u003C\u002Fp\u003E\n\u003Cp\u003EThis pattern is especially useful when you are building mobile applications together with web applications, both \u003Cstrong\u003Esharing a common API\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EUsually, on the mobile application, you might want to show the same elements you show on the website, but with less detail, because \u003Cstrong\u003Eit might be impossible to show on small screens all the available informations the full API provides\u003C\u002Fstrong\u003E. For example if we are displaying the recent users on a website we might want to show all the possibile details but on a mobile app we would hide for example their registration time, or their full name.\u003C\u002Fp\u003E\n\u003Cp\u003EYou could of course keep using the same API you use for the web, but this is not ideal because it means that \u003Cstrong\u003Eyou are downloading data that is partially not being used by your client\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EThe Backend for Frontend pattern tries to solve this issue. Instead of having only one API endpoint for all your devices, you would implement two (or more) API endpoints, each dealing with a different kind of device and application and each \u003Cstrong\u003Eproviding only the needed information\u003C\u002Fstrong\u003E (nothing more and nothing less).\u003C\u002Fp\u003E\n\u003Cp\u003EFor example instead of \u003Ccode\u003E\u002Fapi\u002Fpages\u003C\u002Fcode\u003E you would have \u003Ccode\u003E\u002Fapi\u002Fdesktop\u002Fpages\u003C\u002Fcode\u003E and \u003Ccode\u003E\u002Fapi\u002Fmobile\u002Fpages\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EAgain you would need to develop an additional service, but this way you might save some precious time (and data) for your API clients.\u003C\u002Fp\u003E\n\u003Cp\u003EYou could combine this pattern with the previous one I presented to get best of both worlds: save data and save requests.\u003C\u002Fp\u003E\n\u003Ch2 id=\"summing-up\"\u003E\u003Ca href=\"#summing-up\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESumming up\u003C\u002Fh2\u003E\n\u003Cp\u003EIf you are building a small and personal project you don't have to matter with the issues and solutions presented here. These ideas are important when you are building APIs and software for hundred of thousands of users, but I decided to investigate them for learning purposes. Let me know what you think in the comments.\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"gsoc-updates\"\u003E\u003Ca href=\"#gsoc-updates\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EGSoC updates\u003C\u002Fh3\u003E\n\u003Cp\u003EIn this last month of GSoC I was busy researching and testing various libraries to manage user authentication (think of login, logout and registering functionalities) that worked well with Vue.js. In the end, since we are going to use Keycloak for authenticating user in the WikiToLearn backend, I had to choose a library to integrate with Keycloak and, since there were none to integrate with Vue.js, I had to \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fcrisbal\u002Fvue-keycloak\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ecreate one kinda from scratch\u003C\u002Fa\u003E. The last few days of GSoC will be spent completing and polishing this library which I plan to work on ever after GSoC. It is an \"external\" project but it is very related to [the project I am developing]({{ site.url }}\u002Fblog\u002Fgsoc-at-ke).\u003C\u002Fp\u003E\n","excerpt":"Discover some patterns and ideas for optimizing APIs when developing web and mobile applications"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.29a151e2.js" defer></script><script src="/assets/js/page--src--templates--post-vue.1dff21f4.js" defer></script>
  </body>
</html>
